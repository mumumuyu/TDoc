# 计算机网络

## HTTP/TCP部分：

### OSI七层模型

- 应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如**域名系统DNS**，支持万维网应用的**HTTP协议**，**支持电子邮件的SMTP协议**等。 

- 表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。 

- 会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。 

- 传输层：应用层的数据包传给传输层，它负责提供通用的数据传输服务。该层主要有以下两种协议：  

  - **TCP**：提供面向连接的、可靠的数据传输服务； 
  - **UDP**：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。

- 网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括**IP协议**。 

- 链路层：将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。

- 物理层 ：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。

  

### TCP/IP四层模型

- 应用层(HTTP)：决定了用户提供应用服务时的通信的活动（发出HTTP请求）

- 传输层(TCP)：提供处于网络连接中的两台计算机的数据传输（解析请求）

- 网络层(IP)：选择网络流动传输路线（转发）

- 链路层+物理层：两者合称为“网络接口层”。将网络层传过来的数据进行封装并发送到另一台设备上。




### 三次握手是什么（保证连接的可靠性）：

答：三次握手其实就是指建立一个TCP连接时，需要客户端和服务端总共发送三个包，TCP协议使用三次握手策略来实现可靠性。

1)第一次握手是由客户端给服务端发送一个带有**SYN**（表示同步的意思）的报文，并指明客户端的初始化序列号ISN。

2)第二次握手是在服务端收到客户端的SYN报文后，会以自己的SYN的报文作为应答，并且也是指定来自己的初始化序列号ISN。同时会把客户的ISN+1作为其**ACK**（表示响应的意思）的值，表示自己已经接收到了客户端的SYN，发送给客户端。

3)第三次握手是客户端在收到SYN报文之后，会发送一个带有ACK的报文，当然，也是把服务端的ISN+1作为其ACK的值，表示已经收到了客户端的SYN报文。

当服务端收到ACK报文之后，此时的双方已经建立起了连接。

 

### 三次握手的目的？两次握手为什么不行？

- 第一次握手，服务端可以得出结论：客户端的发送能力，和服务端接收能力是否正常
- 第二次握手，客户端可以得出结论：服务端接收能力以及发送能力，和客户端接收能力以及发送能力是否正常。但是仅仅通过二次握手，**并不能使服务端确认客户端的接收能力是否正常**。

- 第三次握手，可以使客户端以及服务端都能确认彼此的接收，发送能力是否正常

 

### 在发送报文时，携带自身的初始化序列值ISN是否固定？

答：不是固定的。三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。**如果 ISN** **是固定的，攻击者很容易猜出后续的确认号，因此 ISN** **是动态生成的。**

 

### 三次握手过程中，能否写到数据？

答：其实在第三次握手时，可以携带数据，而一二次是不可以的。

 

### 四次挥手的过程

答：建立一个连接的过程需要三次握手，而终止一个连接需要经历四次挥手的过程。这是由TCP的半关闭造成的(TCP提供了连接的一端在结束他的发送后还能接收另一端数据能力)。

假如是由客户端发起的关闭请求，四次挥手过程如下：

1)第一次挥手：客户端发送一个带有FIN的报文，其中报文会指定一个序列号，并且会停止再发送数据，主动关闭TCP连接，等待服务端的确认。

2)第二次挥手：服务端收到FIN的报文，会发送一个带有ACK的报文，并且会把客户端发送来的序列号值+1作为ACK的值，表明服务端已接收到了客户端的报文了。

3)第三次挥手：如果服务端也想断开连接，那么和客户端第一次挥手一样，也发送一个FIN的报文，并且指定服务端的初始化序列号。

4)第四次挥手：客户端收到FIN报文后，一样发送一个带有ACK的报文作为应答，其值等于服务端的初始化序列号+1，服务端收到ACK报文后，就关闭连接状态了。

 

### 挥手为什么需要四次？

答：因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文。因此不能一起发送。故需要四次挥手。

 

### TCP与UDP的区别？

- TCP是面向连接的(需要在交互之前建立连接)；而UDP是无连接的
- TCP提供可靠性服务，使用流量控制和拥塞控制，而UDP尽最大努力交付，不保证可靠性
- UDP具有较好的实时性

- TCP对系统资源要求较多，UDP要求较少

 

### TCP协议如何保证可靠性（传输的）？

答：TCP主要提供了检验和、序列号确认应答、超时重传、滑动窗口、拥塞控制和流量控制等方法实现了可靠性传输。

- 检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢 弃TCP段，重新发送。 
- 序列号确认应答： 序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。 TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文， **这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发**。 
- 滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。 
- 超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。 
- 拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。 
- 流量控制：如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中， 若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。



### 拥塞控制

答：TCP 一共使用了四种算法来实现拥塞控制： **慢开始** (slow-start)； **拥塞避免** (congestion avoidance)； **快速重传** (fast retransmit)； **快速恢复** (fast recovery)。发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。

- 慢开始：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。 

- 拥塞避免：慢开始算法结束后执行拥塞避免算法，在该阶段拥塞窗口值按照线性增长的形式进行，当拥塞窗口的值到达一定的数值时，发送方发送的数据发生了超时重传，此时判断网络出现了拥塞，接下来下执行两步操作，第一、拥塞窗口的**门限值**更新为发生拥塞时的窗口值的一半。第二、把拥塞**窗口值减小到1**，重新执行慢开始算法。

  ![img](https://img-blog.csdnimg.cn/20211001093934830.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQOi3r-WPow==,size_20,color_FFFFFF,t_70,g_se,x_16)

- 快重传：我们可以剔除一些不必要的拥塞报文，提快重传规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

- 快恢复：主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh 门限减半（为了预防网络发生拥塞），但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。

  ![img](https://img-blog.csdnimg.cn/2021100109401121.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQOi3r-WPow==,size_20,color_FFFFFF,t_70,g_se,x_16)



### HTTP常见的状态码有哪些？

答：1XX：接受的请求正在处理。

2XX：成功状态码；请求正常处理完毕。

3XX：重定向状态码；301和302都表示重定向，就是说浏览器在服务端拿到返回的这个状态码就会自动跳转到另一个新的url地址，不同的地方是301原来旧地址的资源被永久地移除了而302表示旧地址的资源仍可访问。

4XX：客户端错误状态码；404找不到资源

5XX：服务端错误状态码；服务端遇到错误，无法完成请求。



### GET请求和POST请求的区别？

答：HTTP常用的请求：PUT、DELETE、POST、GET 可以理解为客户端对服务端数据的增删改查。

使用上的区别：

- GET是通过url或cookie传参，而POST将数据放在BODY中。
- GET方法提交的数据有长度限制，而POST的可以非常大。
- POST比GET更安全，因为数据在地址栏上不可见。

本质上的区别：GET请求是幂等性的，幂等性是指一次和多次请求某一个资源应该返回同一个结果，而POST不是。



### HTTP1.0和HTTP1.1和HTTP2.0的区别?

HTTP1.0：无状态、无连接

HTTP1.1：默认支持长连接（建立一个长连接可以用来发送多个请求，而短连接是发一个请求建立一个连接），增加了缓存处理，增加了Host字段

HTTP2.0：启用多路复用，头部压缩，二进制分帧，支持服务器推送



### HTTP 与 HTTPS 的区别？

答：HTTP默认端口号为80而HTTPS默认端口号为443；HTTP协议无加密，安全性较差，而HTTPS协议有SSL加密协议，安全性高；HTTPS需要证书而HTTP不需要。



### 在浏览器中输入url地址后执行的全部过程？

域名解析（域名 www.baidu.com 变为 ip 地址）。 浏览器搜索自己的DNS缓存（维护一张域名与IP的对应表）；若没有，则搜索操作系统的DNS 缓存（维护一张域名与IP的对应表）；若没有，则搜索操作系统的hosts文件（维护一张域名与IP 的对应表）。 若都没有，则找 tcp/ip 参数中设置的首选 dns 服务器，即本地 dns 服务器（递归查询），本地 域名服务器查询自己的dns缓存，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。 

发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 80 端口发起 tcp 的连接。 

建立 tcp 连接后发起 http 请求。 

服务器响应 http 请求，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处 理请求，处理之后就返回给浏览器 html 文件。 

浏览器解析 html 代码，并请求 html 中的资源。 

浏览器对页面进行渲染，并呈现给用户。



### Cookie和Session的区别？

答：Cookie是服务器发送到用户浏览器并保存到本地的一小块数据，它在浏览器下一次向同一服务器发送请求时会一块发送到服务器上，通常它用于告知服务器两个请求是否来自同一个浏览器。Session代表着服务端和客户端的一次会话（**用户打开浏览器访问了很多页面，访问完成后关闭浏览器的过程称为一次会话**）的过程，Session对象中存储了特定用户会话所需要的属性以及配置信息。

- cookie保存在客户端，session保存在服务端；
- cookie一般不用来存储隐私数据，用session来存储会比较安全；
- cookie只能保存ASCII，而session能保存任意数据类型；
- cookie有存储大小限制，而session存储能力远高于cookie；

