# 计算机网络

## HTTP/TCP部分：

### OSI七层模型

- 应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如**域名系统DNS**，支持万维网应用的**HTTP协议**，**支持电子邮件的SMTP协议**等。 

- 表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。 

- 会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。 

- 传输层：应用层的数据包传给传输层，它负责提供通用的数据传输服务。该层主要有以下两种协议：  

  - **TCP**：提供面向连接的、可靠的数据传输服务； 
  - **UDP**：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。

- 网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括**IP协议**。 

- 链路层：将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。

- 物理层 ：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。

  

### TCP/IP四层模型

- 应用层(HTTP)：决定了用户提供应用服务时的通信的活动（发出HTTP请求）

- 传输层(TCP)：提供处于网络连接中的两台计算机的数据传输（解析请求）

- 网络层(IP)：选择网络流动传输路线（转发）

- 链路层+物理层：两者合称为“网络接口层”。将网络层传过来的数据进行封装并发送到另一台设备上。



### TCP请求头

TCP报文是TCP层传输的数据单元，也叫报文段。

![img](https://img-blog.csdnimg.cn/img_convert/1a7d952f8a1760c33c6e5e3d239af294.png)

由上图中的 TCP 报文格式可知，TCP 报文首部有 20 字节的固定首部以及最大长度为 40 字节的偏移数据构成，即 TCP 报文头部最大 60 字节（计算方式后面会讲）。

其中固定首部包括：

端口号
包括源端口号和目的端口号两部分，分别占 2 字节，用来标识同一台计算机的不同的应用进程。

TCP 报头中的源端口号和目的端口号同 IP 数据报中的源 IP 与目的 IP 唯一确定一条 TCP 连接。

序列号和确认号
序号是本报文段发送的数据组的第一个字节的序号。在 TCP 传送的流中，每一个字节一个序号。

如一个报文段的序号为 300，此报文段数据部分共有 100 字节，则下一个报文段的序号为 400。所以序号确保了 TCP 传输的有序性。确认号，指下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当 ACK 标志为 1 时才有效。比如建立连接时，SYN 报文的 ACK 标志位为 0。

序号和确认号分别占 4 字节。

数据偏移或首部长度
首部长度也叫数据偏移，因为首部可能含有可选项内容，因此 TCP 报头的长度是不确定的，首部长度实际上指示了数据区在报文段中的起始偏移值。

由于首部长度只占到了 4bit 大小，所以能表示的最大长度是 2^4 - 1 = 15，同时它的单位是 4 字节，所以首部最大长度是 4 * 15 = 60 字节。

保留：6 位

控制位：6 位

包括 URG、ACK、PSH、RST、SYN 和 FIN 六个，每一个标志位表示一个控制功能。

1）URG：紧急指针标志，为 1 时表示紧急指针有效，为 0 则忽略紧急指针。

2）ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。

3）PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。

4）RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。

5）SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。

6）FIN：结束标志，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。

窗口：2 字节
滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小是一个 16bit 的字段，因而窗口大小最大为 65535。

校验和：2 字节
奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。

紧急指针：2 字节
只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。

选项和填充
最常见的可选字段是最长报文大小，又称为 MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志为 1 的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是 32 位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证 TCP 头是 32 的整数倍。

数据部分
TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。

如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。


### 三次握手是什么（保证连接的可靠性）：

答：三次握手其实就是指建立一个TCP连接时，需要客户端和服务端总共发送三个包，TCP协议使用三次握手策略来实现可靠性。

1)第一次握手是由客户端给服务端发送一个带有**SYN**（表示同步的意思）的报文，并指明客户端的初始化序列号ISN。

2)第二次握手是在服务端收到客户端的SYN报文后，会以自己的SYN的报文作为应答，并且也是指定来自己的初始化序列号ISN。同时会把客户的ISN+1作为其**ACK**（表示响应的意思）的值，表示自己已经接收到了客户端的SYN，发送给客户端。

3)第三次握手是客户端在收到SYN报文之后，会发送一个带有ACK的报文，当然，也是把服务端的ISN+1作为其ACK的值，表示已经收到了客户端的SYN报文。

当服务端收到ACK报文之后，此时的双方已经建立起了连接。

 

### 三次握手的目的？两次握手为什么不行？

- 第一次握手，服务端可以得出结论：客户端的发送能力，和服务端接收能力是否正常
- 第二次握手，客户端可以得出结论：服务端接收能力以及发送能力，和客户端接收能力以及发送能力是否正常。但是仅仅通过二次握手，**并不能使服务端确认客户端的接收能力是否正常**。

- 第三次握手，可以使客户端以及服务端都能确认彼此的接收，发送能力是否正常

 

### 在发送报文时，携带自身的初始化序列值ISN是否固定？

答：不是固定的。三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。**如果 ISN** **是固定的，攻击者很容易猜出后续的确认号，因此 ISN** **是动态生成的。**

 

### 三次握手过程中，能否写到数据？

答：其实在第三次握手时，可以携带数据，而一二次是不可以的。

 

### 四次挥手的过程

答：建立一个连接的过程需要三次握手，而终止一个连接需要经历四次挥手的过程。这是由TCP的半关闭造成的(TCP提供了连接的一端在结束他的发送后还能接收另一端数据能力)。

假如是由客户端发起的关闭请求，四次挥手过程如下：

1)第一次挥手：客户端发送一个带有FIN的报文，其中报文会指定一个序列号，并且会停止再发送数据，主动关闭TCP连接，等待服务端的确认。

2)第二次挥手：服务端收到FIN的报文，会发送一个带有ACK的报文，并且会把客户端发送来的序列号值+1作为ACK的值，表明服务端已接收到了客户端的报文了。

3)第三次挥手：如果服务端也想断开连接，那么和客户端第一次挥手一样，也发送一个FIN的报文，并且指定服务端的初始化序列号。

4)第四次挥手：客户端收到FIN报文后，一样发送一个带有ACK的报文作为应答，其值等于服务端的初始化序列号+1，服务端收到ACK报文后，就关闭连接状态了。

 

### 挥手为什么需要四次？

答：因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文。因此不能一起发送。故需要四次挥手。

 

### TCP与UDP的区别？

- TCP是面向连接的(需要在交互之前建立连接)；而UDP是无连接的
- TCP提供可靠性服务，使用流量控制和拥塞控制，而UDP尽最大努力交付，不保证可靠性
- UDP具有较好的实时性

- TCP对系统资源要求较多，UDP要求较少

 

### TCP协议如何保证可靠性（传输的）？

答：TCP主要提供了检验和、序列号确认应答、超时重传、滑动窗口、拥塞控制和流量控制等方法实现了可靠性传输。

- 检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢 弃TCP段，重新发送。 
- 序列号确认应答： 序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。 TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文， **这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发**。 
- 滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。 
- 超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。 
- 拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。 
- 流量控制：如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中， 若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。



### 拥塞控制

答：TCP 一共使用了四种算法来实现拥塞控制： **慢开始** (slow-start)； **拥塞避免** (congestion avoidance)； **快速重传** (fast retransmit)； **快速恢复** (fast recovery)。发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。

- 慢开始：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。 (**指数增长**)

- 拥塞避免：慢开始算法结束后执行拥塞避免算法，在该阶段拥塞窗口值按照**线性增长**的形式进行，当拥塞窗口的值到达一定的数值时，发送方发送的数据发生了超时重传，此时判断网络出现了拥塞，接下来下执行两步操作，第一、拥塞窗口的**门限值**更新为发生拥塞时的窗口值的一半。第二、把拥塞**窗口值减小到1**，重新执行慢开始算法。

  ![img](https://img-blog.csdnimg.cn/20211001093934830.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQOi3r-WPow==,size_20,color_FFFFFF,t_70,g_se,x_16)

- 快重传：我们可以剔除一些不必要的拥塞报文，提快重传规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

- 快恢复：主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh 门限减半（为了预防网络发生拥塞），但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。

  ![img](https://img-blog.csdnimg.cn/2021100109401121.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQOi3r-WPow==,size_20,color_FFFFFF,t_70,g_se,x_16)



### HTTP常见的状态码有哪些？

答：1XX：接受的请求正在处理。

2XX：成功状态码；请求正常处理完毕。

3XX：重定向状态码；301和302都表示重定向，就是说浏览器在服务端拿到返回的这个状态码就会自动跳转到另一个新的url地址，不同的地方是301原来旧地址的资源被永久地移除了而302表示旧地址的资源仍可访问。

4XX：客户端错误状态码；404找不到资源

5XX：服务端错误状态码；服务端遇到错误，无法完成请求。



### GET请求和POST请求的区别？

答：HTTP常用的请求：PUT、DELETE、POST、GET 可以理解为客户端对服务端数据的增删改查。

使用上的区别：

- GET是通过url或cookie传参，而POST将数据放在BODY中。
- GET方法提交的数据有长度限制，而POST的可以非常大。
- POST比GET更安全，因为数据在地址栏上不可见。

本质上的区别：GET请求是幂等性的，幂等性是指一次和多次请求某一个资源应该返回同一个结果，而POST不是。



### HTTP1.0和HTTP1.1和HTTP2.0的区别?

HTTP1.0：无状态、无连接

HTTP1.1：默认支持长连接（建立一个长连接可以用来发送多个请求，而短连接是发一个请求建立一个连接），增加了缓存处理，增加了Host字段

HTTP2.0：启用多路复用，头部压缩，二进制分帧，支持服务器推送



### HTTP 与 HTTPS 的区别？

答：HTTP默认端口号为80而HTTPS默认端口号为443；HTTP协议无加密，安全性较差，而HTTPS协议有SSL加密协议，安全性高；HTTPS需要证书而HTTP不需要。



### 在浏览器中输入url地址后执行的全部过程？

域名解析（域名 www.baidu.com 变为 ip 地址）。 浏览器搜索自己的DNS缓存（维护一张域名与IP的对应表）；若没有，则搜索操作系统的DNS 缓存（维护一张域名与IP的对应表）；若没有，则搜索操作系统的hosts文件（维护一张域名与IP 的对应表）。 若都没有，则找 tcp/ip 参数中设置的首选 dns 服务器，即本地 dns 服务器（递归查询），本地 域名服务器查询自己的dns缓存，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。 

发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 80 端口发起 tcp 的连接。 

建立 tcp 连接后发起 http 请求。 

服务器响应 http 请求，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处 理请求，处理之后就返回给浏览器 html 文件。 

浏览器解析 html 代码，并请求 html 中的资源。 

浏览器对页面进行渲染，并呈现给用户。



### Cookie和Session的区别？

答：Cookie是服务器发送到用户浏览器并保存到本地的一小块数据，它在浏览器下一次向同一服务器发送请求时会一块发送到服务器上，通常它用于告知服务器两个请求是否来自同一个浏览器。Session代表着服务端和客户端的一次会话（**用户打开浏览器访问了很多页面，访问完成后关闭浏览器的过程称为一次会话**）的过程，Session对象中存储了特定用户会话所需要的属性以及配置信息。

- cookie保存在客户端，session保存在服务端；
- cookie一般不用来存储隐私数据，用session来存储会比较安全；
- cookie只能保存ASCII，而session能保存任意数据类型；
- cookie有存储大小限制，而session存储能力远高于cookie；

