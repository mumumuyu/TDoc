# 一些常用工具类

### 动态代理

```java
public class ProxyInvocation implements InvocationHandler {

    private Object target;

    public void setTarget(Object target) {
        this.target = target;
    }

    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces()
                ,this);
    }

    /**
     *处理代理实例，并返回结果
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        log(method.getName());
        Object result = method.invoke(target, args);
        return result;
    }
    public void log(String msg){
        System.out.println("执行力"+ msg +"方法");
    }
}
```

### 验证码

1.效果

点击验证码可以获取新的验证码

![img](https://img-blog.csdnimg.cn/20200324172548109.png)

2.原理

后台生成验证码图片，将图片传到前台。 
后台在session中保存验证码内容。 
前台输入验证码后传到后台在后台取出session中保存的验证码进行校验。

注意，验证码的明文是不能传送到前端的。前端内容都是透明的，不安全。验证码是用来防机器人并不是单单防人。如果把验证码明文传到前端很容易就会被破解。

3.图片生成

验证码生成工具类RandomValidateCodeUtil

```java
package com.lgd.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.imageio.ImageIO;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.Random;

public class RandomValidateCodeUtil {


    public static final String RANDOMCODEKEY= "RANDOMVALIDATECODEKEY";//放到session中的key
//    private String randString = "0123456789";//随机产生只有数字的字符串 private String
    //private String randString = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";//随机产生只有字母的字符串
    private String randString = "23456789ABCDEFGHJKMNOPQRSTUVWXY";//随机产生数字与字母组合的字符串
    private int width = 95;// 图片宽
    private int height = 25;// 图片高
    private int lineSize = 40;// 干扰线数量
    private int stringNum = 4;// 随机产生字符数量

    private static final Logger logger =  LoggerFactory.getLogger(RandomValidateCodeUtil.class);

    private Random random = new Random();

    /**
     * 获得字体
     */
    private Font getFont() {
        return new Font("Fixedsys", Font.CENTER_BASELINE, 18);
    }

    /**
     * 获得颜色
     */
    private Color getRandColor(int fc, int bc) {
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc - 16);
        int g = fc + random.nextInt(bc - fc - 14);
        int b = fc + random.nextInt(bc - fc - 18);
        return new Color(r, g, b);
    }

    /**
     * 生成随机图片
     */
    public void getRandcode(HttpServletRequest request, HttpServletResponse response) {
        HttpSession session = request.getSession();
        // BufferedImage类是具有缓冲区的Image类,Image类是用于描述图像信息的类
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_BGR);
        Graphics g = image.getGraphics();// 产生Image对象的Graphics对象,改对象可以在图像上进行各种绘制操作
        g.fillRect(0, 0, width, height);//图片大小
        g.setFont(new Font("Times New Roman", Font.ROMAN_BASELINE, 18));//字体大小
        g.setColor(getRandColor(110, 133));//字体颜色
        // 绘制干扰线
        for (int i = 0; i <= lineSize; i++) {
            drowLine(g);
        }
        // 绘制随机字符
        String randomString = "";
        for (int i = 1; i <= stringNum; i++) {
            randomString = drowString(g, randomString, i);
        }
        logger.info(randomString);
        //将生成的随机字符串保存到session中
        session.removeAttribute(RANDOMCODEKEY);
        session.setAttribute(RANDOMCODEKEY, randomString);
        g.dispose();
        try {
            // 将内存中的图片通过流动形式输出到客户端
            ImageIO.write(image, "JPEG", response.getOutputStream());
        } catch (Exception e) {
            logger.error("将内存中的图片通过流动形式输出到客户端失败>>>>   ", e);
        }

    }

    /**
     * 绘制字符串
     */
    private String drowString(Graphics g, String randomString, int i) {
        g.setFont(getFont());
        g.setColor(new Color(random.nextInt(101), random.nextInt(111), random
                .nextInt(121)));
        String rand = String.valueOf(getRandomString(random.nextInt(randString
                .length())));
        randomString += rand;
        g.translate(random.nextInt(3), random.nextInt(3));
        g.drawString(rand, 13 * i, 16);
        return randomString;
    }

    /**
     * 绘制干扰线
     */
    private void drowLine(Graphics g) {
        int x = random.nextInt(width);
        int y = random.nextInt(height);
        int xl = random.nextInt(13);
        int yl = random.nextInt(15);
        g.drawLine(x, y, x + xl, y + yl);
    }

    /**
     * 获取随机的字符
     */
    public String getRandomString(int num) {
        return String.valueOf(randString.charAt(num));
    }
}

```

在Controller调用生成验证码图片方法并将图片传到前端

```java
/**
     * 生成验证码
     */
    @RequestMapping(value = "/getVerify")
    public void getVerify(HttpServletRequest request, HttpServletResponse response) {
        try {
            //设置相应类型,告诉浏览器输出的内容为图片
            response.setContentType("image/jpeg");
            //设置响应头信息，告诉浏览器不要缓存此内容
            response.setHeader("Pragma", "No-cache");
            response.setHeader("Cache-Control", "no-cache");
            response.setDateHeader("Expire", 0);
            RandomValidateCodeUtil randomValidateCode = new RandomValidateCodeUtil();
            //输出验证码图片方法
            randomValidateCode.getRandcode(request, response);
        } catch (Exception e) {
            LOG.error("获取验证码失败>>>>   ", e);
        }
    }
```

前端获取验证码图片 
html

```javascript
<div class="layui-form-item">
          <label class="layui-form-label"><i class="layui-icon layui-icon-vercode"></i></label>
          <div class="layui-input-block">
            <div class="layui-row inline-block">
              <div class="layui-col-xs7">
                <input name="yzm" type="text" placeholder="验证码" class="layui-input"
                       autocomplete="off" lay-verType="tips" lay-verify="required" required/>
              </div>
              <div class="layui-col-xs5" style="padding-left: 6px;">
                <a href="javascript:void(0);" title="点击更换验证码">
                <img name="img" class="login-captcha" src="/getVerify" onclick="refresh()">
                </a>
              </div>
            </div>
          </div>
        </div>
```

js

```javascript
function refresh() {
      loginForm.img.src = "/getVerify?id=" + Math.random();
    }
```

每次点击图片重新刷新验证码 
界面初次加载时，调用getVerify()方法即可。

4.验证码验证

前端获取用户输入的验证码，传到后台进行验证。 
后台验证代码

```typescript
/**
     * 忘记密码页面校验验证码
     */
    @RequestMapping(value = "/checkVerify", method = RequestMethod.POST, headers = "Accept=application/json")
    public ResBody checkVerify(@RequestBody Map<String, Object> requestMap, HttpSession session) {
        ResBody resBody = new ResBody();
        try{
            //从session中获取随机数
            String inputStr = requestMap.get("yzm").toString();
            String random = (String) session.getAttribute("RANDOMVALIDATECODEKEY");
            if (random == null) {
                resBody.setCode(500);
                resBody.setMsg("未获取验证码");
            }
            if (random.equals(inputStr)) {
                resBody.setCode(200);
            } else {
                resBody.setCode(500);
                resBody.setMsg("验证码输入错误");
            }
        }catch (Exception e){
            LOG.error("验证码校验失败", e);
            resBody.setCode(500);
        }
        return resBody;
    }
```


后台校验

### 通用过滤器

```java
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;
 
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
 
/**
 * 通用编码解决方案
 * 
 */
public class GenericEncodingFilter implements Filter {
	@Override
	public void destroy() {
	}
 
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		// 转型为与协议相关对象
		HttpServletRequest httpServletRequest = (HttpServletRequest) request;
		// 对request包装增强
		HttpServletRequest myrequest = new MyRequest(httpServletRequest);
		chain.doFilter(myrequest, response);
	}
 
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
 
}
 
// 自定义request对象
class MyRequest extends HttpServletRequestWrapper {
 
	private HttpServletRequest request;
 
	private boolean hasEncode;
 
	public MyRequest(HttpServletRequest request) {
		super(request);// super必须写
		this.request = request;
	}
 
	// 对需要增强方法 进行覆盖
	@Override
	public Map getParameterMap() {
		// 先获得请求方式
		String method = request.getMethod();
		if (method.equalsIgnoreCase("post")) {
			// post请求
			try {
				// 处理post乱码
				request.setCharacterEncoding("utf-8");
				return request.getParameterMap();
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
			}
		} else if (method.equalsIgnoreCase("get")) {
			// get请求
			Map<String, String[]> parameterMap = request.getParameterMap();
			if (!hasEncode) { // 确保get手动编码逻辑只运行一次
				for (String parameterName : parameterMap.keySet()) {
					String[] values = parameterMap.get(parameterName);
					if (values != null) {
						for (int i = 0; i < values.length; i++) {
							try {
								// 处理get乱码
								values[i] = new String(values[i].getBytes("ISO-8859-1"), "utf-8");
							} catch (UnsupportedEncodingException e) {
								e.printStackTrace();
							}
						}
					}
				}
				hasEncode = true;
			}
			return parameterMap;
		}
 
		return super.getParameterMap();
	}
 
	@Override
	public String getParameter(String name) {
		Map<String, String[]> parameterMap = getParameterMap();
		String[] values = parameterMap.get(name);
		if (values == null) {
			return null;
		}
		return values[0]; // 取回参数的第一个值
	}
 
	@Override
	public String[] getParameterValues(String name) {
		Map<String, String[]> parameterMap = getParameterMap();
		String[] values = parameterMap.get(name);
		return values;
	}
 
}
```

### 帮助测代码量

```java
package com.lgd.utils;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.TreeSet;

public class ErgodicFiles {
    /*
     *下面说的都是IO
     *这里稍微说一下，字节流字符流，
     *字节有8个二进制位组成，计算机里面储存的任何东西，都是以二进制位保存的，所以，任何文件，都可以用字节流来保存操作。
     *字节流，InputStream ,OutputStream
     *但是，如果明确知道这个文件，属于文本文件，并且对这个文本可能进行操作，读取行，写入行等，进行行级操作的时候，用字符流。
     *字符流Reader ,Writer
     *
     *关于NIO的正在研究，
     *IO：流
     *NIO：缓冲区
     */
    static List<File> javalsf = new ArrayList<File>();
    static List<File> lsf = new ArrayList<File>();
    static int javaFileLinenum = 0;

    TreeSet<String> nums = new TreeSet<String>();

    public static void main(String[] args) throws Exception {

        File fir = new File("F:\\IDE\\Easyweb-boke");
        FileOutputStream fio = null;
        try {
            //1、
            //字节流输入文件
            getJavaFiles(fir,lsf);
            fio = new FileOutputStream(new File("/testNumbers.txt"));
            String javastr = "java文件个数是："+javalsf.size()+"个";
            String str = "其他文件个数是："+lsf.size()+"个";
            //输入到文件中。
            fio.write(javastr.getBytes());

            //FileOutputStream 换行
            fio.write("\r\n".getBytes());

            //继续输出文件
            fio.write(str.getBytes());

            fio.write("\r\n".getBytes());
            fio.write("\r\n".getBytes());
            if(javalsf.size()>0){
                for(File javafir : javalsf){
                    getJavaFileNum(javafir);
                }
            }
            String numstr = "java代码的行数是："+javaFileLinenum;
            fio.write(numstr.getBytes());

            //2、
            //字符流输入文件
            //FileWriter fw = new FileWriter("w:/zfAllFile.txt");


        } catch (Exception e) {
            e.printStackTrace();
        }finally{
            if(fio!=null){
                fio.close();
            }
        }
    }


    //循环路径下所有的文件。
    public static List<File> getJavaFiles (File fir, List<File> listfile){

        //判断文件是否存在
        if (!fir.exists()){
            System.out.println("文件名称不存在!");
        }else{
            //判断是否是文件
            if (fir.isFile()){
                //如果当前fir是文件，则判断是什么文件
                String firName = fir.getName();//获取文件名

                //System.err.println(firName.hashCode());  获取文件后缀名
                if(firName.substring(firName.lastIndexOf(".")+1) .equals("html")){
                    javalsf.add(fir);
                }else{
                    lsf.add(fir);
                }
            } else{
                //如果当前fir是文件夹，则遍历整个文件夹为File数组，继续循环遍历
                File[] files = fir.listFiles();
                for (int i = 0; i < files.length; i++  ){
                    getJavaFiles(files[i], listfile);
                }
            }
        }

        return lsf;
    }

    //查看java文件中的代码数量
    public static void getJavaFileNum(File fir){
        int num = 0 ;
        try {
            //不能指定编码格式，会出现乱码问题
            //FileReader reader = new FileReader(new File("w:/test.java"));

            System.out.println("查看的文件是："+fir.getName());
            System.out.println("当前文件的路径是"+fir.getPath());
            //可以指定编码格式。
            InputStreamReader isr=new InputStreamReader(new FileInputStream(fir),"GBK");
            BufferedReader br = new BufferedReader(isr);
            String str = null;
            while ((str = br.readLine()) != null) {
                if(!str.startsWith("//")&&!str.equals("")){
                    num ++;
                }
            }
            System.out.println("num的数量是："+num);
            br.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        javaFileLinenum += num;
        System.out.println("Java代码的总量是："+javaFileLinenum);
    }
}
```
