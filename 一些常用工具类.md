# 一些常用工具类

### 动态代理

```java
public class ProxyInvocation implements InvocationHandler {

    private Object target;

    public void setTarget(Object target) {
        this.target = target;
    }

    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces()
                ,this);
    }

    /**
     *处理代理实例，并返回结果
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        log(method.getName());
        Object result = method.invoke(target, args);
        return result;
    }
    public void log(String msg){
        System.out.println("执行力"+ msg +"方法");
    }
}
```

### 验证码

1.效果

点击验证码可以获取新的验证码

![img](https://img-blog.csdnimg.cn/20200324172548109.png)

2.原理

后台生成验证码图片，将图片传到前台。 
后台在session中保存验证码内容。 
前台输入验证码后传到后台在后台取出session中保存的验证码进行校验。

注意，验证码的明文是不能传送到前端的。前端内容都是透明的，不安全。验证码是用来防机器人并不是单单防人。如果把验证码明文传到前端很容易就会被破解。

3.图片生成

验证码生成工具类RandomValidateCodeUtil

```java
package com.lgd.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.imageio.ImageIO;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.Random;

public class RandomValidateCodeUtil {


    public static final String RANDOMCODEKEY= "RANDOMVALIDATECODEKEY";//放到session中的key
//    private String randString = "0123456789";//随机产生只有数字的字符串 private String
    //private String randString = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";//随机产生只有字母的字符串
    private String randString = "23456789ABCDEFGHJKMNOPQRSTUVWXY";//随机产生数字与字母组合的字符串
    private int width = 95;// 图片宽
    private int height = 25;// 图片高
    private int lineSize = 40;// 干扰线数量
    private int stringNum = 4;// 随机产生字符数量

    private static final Logger logger =  LoggerFactory.getLogger(RandomValidateCodeUtil.class);

    private Random random = new Random();

    /**
     * 获得字体
     */
    private Font getFont() {
        return new Font("Fixedsys", Font.CENTER_BASELINE, 18);
    }

    /**
     * 获得颜色
     */
    private Color getRandColor(int fc, int bc) {
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc - 16);
        int g = fc + random.nextInt(bc - fc - 14);
        int b = fc + random.nextInt(bc - fc - 18);
        return new Color(r, g, b);
    }

    /**
     * 生成随机图片
     */
    public void getRandcode(HttpServletRequest request, HttpServletResponse response) {
        HttpSession session = request.getSession();
        // BufferedImage类是具有缓冲区的Image类,Image类是用于描述图像信息的类
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_BGR);
        Graphics g = image.getGraphics();// 产生Image对象的Graphics对象,改对象可以在图像上进行各种绘制操作
        g.fillRect(0, 0, width, height);//图片大小
        g.setFont(new Font("Times New Roman", Font.ROMAN_BASELINE, 18));//字体大小
        g.setColor(getRandColor(110, 133));//字体颜色
        // 绘制干扰线
        for (int i = 0; i <= lineSize; i++) {
            drowLine(g);
        }
        // 绘制随机字符
        String randomString = "";
        for (int i = 1; i <= stringNum; i++) {
            randomString = drowString(g, randomString, i);
        }
        logger.info(randomString);
        //将生成的随机字符串保存到session中
        session.removeAttribute(RANDOMCODEKEY);
        session.setAttribute(RANDOMCODEKEY, randomString);
        g.dispose();
        try {
            // 将内存中的图片通过流动形式输出到客户端
            ImageIO.write(image, "JPEG", response.getOutputStream());
        } catch (Exception e) {
            logger.error("将内存中的图片通过流动形式输出到客户端失败>>>>   ", e);
        }

    }

    /**
     * 绘制字符串
     */
    private String drowString(Graphics g, String randomString, int i) {
        g.setFont(getFont());
        g.setColor(new Color(random.nextInt(101), random.nextInt(111), random
                .nextInt(121)));
        String rand = String.valueOf(getRandomString(random.nextInt(randString
                .length())));
        randomString += rand;
        g.translate(random.nextInt(3), random.nextInt(3));
        g.drawString(rand, 13 * i, 16);
        return randomString;
    }

    /**
     * 绘制干扰线
     */
    private void drowLine(Graphics g) {
        int x = random.nextInt(width);
        int y = random.nextInt(height);
        int xl = random.nextInt(13);
        int yl = random.nextInt(15);
        g.drawLine(x, y, x + xl, y + yl);
    }

    /**
     * 获取随机的字符
     */
    public String getRandomString(int num) {
        return String.valueOf(randString.charAt(num));
    }
}

```

在Controller调用生成验证码图片方法并将图片传到前端

```java
/**
     * 生成验证码
     */
    @RequestMapping(value = "/getVerify")
    public void getVerify(HttpServletRequest request, HttpServletResponse response) {
        try {
            //设置相应类型,告诉浏览器输出的内容为图片
            response.setContentType("image/jpeg");
            //设置响应头信息，告诉浏览器不要缓存此内容
            response.setHeader("Pragma", "No-cache");
            response.setHeader("Cache-Control", "no-cache");
            response.setDateHeader("Expire", 0);
            RandomValidateCodeUtil randomValidateCode = new RandomValidateCodeUtil();
            //输出验证码图片方法
            randomValidateCode.getRandcode(request, response);
        } catch (Exception e) {
            LOG.error("获取验证码失败>>>>   ", e);
        }
    }
```

前端获取验证码图片 
html

```javascript
<div class="layui-form-item">
          <label class="layui-form-label"><i class="layui-icon layui-icon-vercode"></i></label>
          <div class="layui-input-block">
            <div class="layui-row inline-block">
              <div class="layui-col-xs7">
                <input name="yzm" type="text" placeholder="验证码" class="layui-input"
                       autocomplete="off" lay-verType="tips" lay-verify="required" required/>
              </div>
              <div class="layui-col-xs5" style="padding-left: 6px;">
                <a href="javascript:void(0);" title="点击更换验证码">
                <img name="img" class="login-captcha" src="/getVerify" onclick="refresh()">
                </a>
              </div>
            </div>
          </div>
        </div>
```

js

```javascript
function refresh() {
      loginForm.img.src = "/getVerify?id=" + Math.random();
    }
```

每次点击图片重新刷新验证码 
界面初次加载时，调用getVerify()方法即可。

4.验证码验证

前端获取用户输入的验证码，传到后台进行验证。 
后台验证代码

```typescript
/**
     * 忘记密码页面校验验证码
     */
    @RequestMapping(value = "/checkVerify", method = RequestMethod.POST, headers = "Accept=application/json")
    public ResBody checkVerify(@RequestBody Map<String, Object> requestMap, HttpSession session) {
        ResBody resBody = new ResBody();
        try{
            //从session中获取随机数
            String inputStr = requestMap.get("yzm").toString();
            String random = (String) session.getAttribute("RANDOMVALIDATECODEKEY");
            if (random == null) {
                resBody.setCode(500);
                resBody.setMsg("未获取验证码");
            }
            if (random.equals(inputStr)) {
                resBody.setCode(200);
            } else {
                resBody.setCode(500);
                resBody.setMsg("验证码输入错误");
            }
        }catch (Exception e){
            LOG.error("验证码校验失败", e);
            resBody.setCode(500);
        }
        return resBody;
    }
```


后台校验

### 通用过滤器

```java
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;
 
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
 
/**
 * 通用编码解决方案
 * 
 */
public class GenericEncodingFilter implements Filter {
	@Override
	public void destroy() {
	}
 
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		// 转型为与协议相关对象
		HttpServletRequest httpServletRequest = (HttpServletRequest) request;
		// 对request包装增强
		HttpServletRequest myrequest = new MyRequest(httpServletRequest);
		chain.doFilter(myrequest, response);
	}
 
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}
 
}
 
// 自定义request对象
class MyRequest extends HttpServletRequestWrapper {
 
	private HttpServletRequest request;
 
	private boolean hasEncode;
 
	public MyRequest(HttpServletRequest request) {
		super(request);// super必须写
		this.request = request;
	}
 
	// 对需要增强方法 进行覆盖
	@Override
	public Map getParameterMap() {
		// 先获得请求方式
		String method = request.getMethod();
		if (method.equalsIgnoreCase("post")) {
			// post请求
			try {
				// 处理post乱码
				request.setCharacterEncoding("utf-8");
				return request.getParameterMap();
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
			}
		} else if (method.equalsIgnoreCase("get")) {
			// get请求
			Map<String, String[]> parameterMap = request.getParameterMap();
			if (!hasEncode) { // 确保get手动编码逻辑只运行一次
				for (String parameterName : parameterMap.keySet()) {
					String[] values = parameterMap.get(parameterName);
					if (values != null) {
						for (int i = 0; i < values.length; i++) {
							try {
								// 处理get乱码
								values[i] = new String(values[i].getBytes("ISO-8859-1"), "utf-8");
							} catch (UnsupportedEncodingException e) {
								e.printStackTrace();
							}
						}
					}
				}
				hasEncode = true;
			}
			return parameterMap;
		}
 
		return super.getParameterMap();
	}
 
	@Override
	public String getParameter(String name) {
		Map<String, String[]> parameterMap = getParameterMap();
		String[] values = parameterMap.get(name);
		if (values == null) {
			return null;
		}
		return values[0]; // 取回参数的第一个值
	}
 
	@Override
	public String[] getParameterValues(String name) {
		Map<String, String[]> parameterMap = getParameterMap();
		String[] values = parameterMap.get(name);
		return values;
	}
 
}
```

### 帮助测代码量

```java
package com.lgd.utils;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.TreeSet;

public class ErgodicFiles {
    /*
     *下面说的都是IO
     *这里稍微说一下，字节流字符流，
     *字节有8个二进制位组成，计算机里面储存的任何东西，都是以二进制位保存的，所以，任何文件，都可以用字节流来保存操作。
     *字节流，InputStream ,OutputStream
     *但是，如果明确知道这个文件，属于文本文件，并且对这个文本可能进行操作，读取行，写入行等，进行行级操作的时候，用字符流。
     *字符流Reader ,Writer
     *
     *关于NIO的正在研究，
     *IO：流
     *NIO：缓冲区
     */
    static List<File> javalsf = new ArrayList<File>();
    static List<File> lsf = new ArrayList<File>();
    static int javaFileLinenum = 0;

    TreeSet<String> nums = new TreeSet<String>();

    public static void main(String[] args) throws Exception {

        File fir = new File("F:\\IDE\\Easyweb-boke");
        FileOutputStream fio = null;
        try {
            //1、
            //字节流输入文件
            getJavaFiles(fir,lsf);
            fio = new FileOutputStream(new File("/testNumbers.txt"));
            String javastr = "java文件个数是："+javalsf.size()+"个";
            String str = "其他文件个数是："+lsf.size()+"个";
            //输入到文件中。
            fio.write(javastr.getBytes());

            //FileOutputStream 换行
            fio.write("\r\n".getBytes());

            //继续输出文件
            fio.write(str.getBytes());

            fio.write("\r\n".getBytes());
            fio.write("\r\n".getBytes());
            if(javalsf.size()>0){
                for(File javafir : javalsf){
                    getJavaFileNum(javafir);
                }
            }
            String numstr = "java代码的行数是："+javaFileLinenum;
            fio.write(numstr.getBytes());

            //2、
            //字符流输入文件
            //FileWriter fw = new FileWriter("w:/zfAllFile.txt");


        } catch (Exception e) {
            e.printStackTrace();
        }finally{
            if(fio!=null){
                fio.close();
            }
        }
    }


    //循环路径下所有的文件。
    public static List<File> getJavaFiles (File fir, List<File> listfile){

        //判断文件是否存在
        if (!fir.exists()){
            System.out.println("文件名称不存在!");
        }else{
            //判断是否是文件
            if (fir.isFile()){
                //如果当前fir是文件，则判断是什么文件
                String firName = fir.getName();//获取文件名

                //System.err.println(firName.hashCode());  获取文件后缀名
                if(firName.substring(firName.lastIndexOf(".")+1) .equals("html")){
                    javalsf.add(fir);
                }else{
                    lsf.add(fir);
                }
            } else{
                //如果当前fir是文件夹，则遍历整个文件夹为File数组，继续循环遍历
                File[] files = fir.listFiles();
                for (int i = 0; i < files.length; i++  ){
                    getJavaFiles(files[i], listfile);
                }
            }
        }

        return lsf;
    }

    //查看java文件中的代码数量
    public static void getJavaFileNum(File fir){
        int num = 0 ;
        try {
            //不能指定编码格式，会出现乱码问题
            //FileReader reader = new FileReader(new File("w:/test.java"));

            System.out.println("查看的文件是："+fir.getName());
            System.out.println("当前文件的路径是"+fir.getPath());
            //可以指定编码格式。
            InputStreamReader isr=new InputStreamReader(new FileInputStream(fir),"GBK");
            BufferedReader br = new BufferedReader(isr);
            String str = null;
            while ((str = br.readLine()) != null) {
                if(!str.startsWith("//")&&!str.equals("")){
                    num ++;
                }
            }
            System.out.println("num的数量是："+num);
            br.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        javaFileLinenum += num;
        System.out.println("Java代码的总量是："+javaFileLinenum);
    }
}
```

### 加密工具类

##### 双向加密AES

```java
AESUtil3.encrypt(msg);//解密
AESUtil3.decrypt(encrypt);//加密
```

```java
public class AESUtil3 {

	private static final String PASSWORD = "abcdefgabcdefg21";

	/**
	 * 加密
	 * 
	 * @param content
	 *            需要加密的内容
	 * @param password
	 *            加密密码
	 * @return
	 */
	public static byte[] encrypt(String content, String password) {
		try {
			KeyGenerator kgen = KeyGenerator.getInstance("AES");
			kgen.init(128, new SecureRandom(password.getBytes()));
			SecretKey secretKey = kgen.generateKey();
			byte[] enCodeFormat = secretKey.getEncoded();
			SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES");
			Cipher cipher = Cipher.getInstance("AES");// 创建密码器
			byte[] byteContent = content.getBytes("utf-8");
			cipher.init(Cipher.ENCRYPT_MODE, key);// 初始化
			byte[] result = cipher.doFinal(byteContent);
			return result; // 加密
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (NoSuchPaddingException e) {
			e.printStackTrace();
		} catch (InvalidKeyException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		} catch (IllegalBlockSizeException e) {
			e.printStackTrace();
		} catch (BadPaddingException e) {
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * 解密
	 * 
	 * @param content
	 *            待解密内容
	 * @param password
	 *            解密密钥
	 * @return
	 */
	public static byte[] decrypt(byte[] content, String password) {
		try {
			KeyGenerator kgen = KeyGenerator.getInstance("AES");
			kgen.init(128, new SecureRandom(password.getBytes()));
			SecretKey secretKey = kgen.generateKey();
			byte[] enCodeFormat = secretKey.getEncoded();
			SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES");
			Cipher cipher = Cipher.getInstance("AES");// 创建密码器
			cipher.init(Cipher.DECRYPT_MODE, key);// 初始化
			byte[] result = cipher.doFinal(content);
			return result; // 加密
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (NoSuchPaddingException e) {
			e.printStackTrace();
		} catch (InvalidKeyException e) {
			e.printStackTrace();
		} catch (IllegalBlockSizeException e) {
			e.printStackTrace();
		} catch (BadPaddingException e) {
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * 将二进制转换成16进制
	 * 
	 * @param buf
	 * @return
	 */
	public static String parseByte2HexStr(byte buf[]) {
		StringBuffer sb = new StringBuffer();
		for (int i = 0; i < buf.length; i++) {
			String hex = Integer.toHexString(buf[i] & 0xFF);
			if (hex.length() == 1) {
				hex = '0' + hex;
			}
			sb.append(hex.toUpperCase());
		}
		return sb.toString();
	}

	/**
	 * 将16进制转换为二进制
	 * 
	 * @param hexStr
	 * @return
	 */
	public static byte[] parseHexStr2Byte(String hexStr) {
		if (hexStr.length() < 1)
			return null;
		byte[] result = new byte[hexStr.length() / 2];
		for (int i = 0; i < hexStr.length() / 2; i++) {
			int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16);
			int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16);
			result[i] = (byte) (high * 16 + low);
		}
		return result;
	}

	/**
	 * 加密
	 *
	 * @param content
	 *            需要加密的内容
	 * @param password
	 *            加密密码
	 * @return
	 */
	public static byte[] encrypt2(String content, String password) {
		try {
			SecretKeySpec key = new SecretKeySpec(password.getBytes(), "AES");
			Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");
			byte[] byteContent = content.getBytes("utf-8");
			cipher.init(Cipher.ENCRYPT_MODE, key);// 初始化
			byte[] result = cipher.doFinal(byteContent);
			return result; // 加密
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (NoSuchPaddingException e) {
			e.printStackTrace();
		} catch (InvalidKeyException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		} catch (IllegalBlockSizeException e) {
			e.printStackTrace();
		} catch (BadPaddingException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static String decrypt(String content) throws UnsupportedEncodingException {
		byte[] decode = parseHexStr2Byte(content);
		byte[] decryptResult = decrypt(decode, PASSWORD);
		return new String(decryptResult, "UTF-8");
	}

	public static String encrypt(String content) throws UnsupportedEncodingException {
		if(content==null||"".equals(content)){
		    content = "null";
        }
	    byte[] encode = encrypt(content, PASSWORD);
		return parseByte2HexStr(encode);
	}
}
```

**AES-Helper**（更安全，帮助生成密码，不过也许没必要）

```java
public class AesUtilHelper {
    private final int keySize;
    private final int iterationCount;
    private final Cipher cipher;
    
    public AesUtilHelper(int keySize, int iterationCount) {
        this.keySize = keySize;
        this.iterationCount = iterationCount;
        try {
            cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        }
        catch (Exception e) {
            throw fail(e);
        }
    }
    
    public String encrypt(String salt, String iv, String passphrase, String plaintext) {
        try {
            SecretKey key = generateKey(salt, passphrase);
            byte[] encrypted = doFinal(Cipher.ENCRYPT_MODE, key, iv, plaintext.getBytes("UTF-8"));
            return base64(encrypted);
        }
        catch (UnsupportedEncodingException e) {
            throw fail(e);
        }
    }
    
    public String decrypt(String salt, String iv, String passphrase, String ciphertext) {
        try {
            SecretKey key = generateKey(salt, passphrase);
            byte[] decrypted = doFinal(Cipher.DECRYPT_MODE, key, iv, base64(ciphertext));
            return new String(decrypted, "UTF-8");
        }
        catch (UnsupportedEncodingException e) {
            throw fail(e);
        }
    }
    
    private byte[] doFinal(int encryptMode, SecretKey key, String iv, byte[] bytes) {
        try {
            cipher.init(encryptMode, key, new IvParameterSpec(hex(iv)));
            return cipher.doFinal(bytes);
        }
        catch (Exception e) {
           e.printStackTrace();
            throw fail(e);
        }
    }
    
    private SecretKey generateKey(String salt, String passphrase) {
        try {
            SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
            KeySpec spec = new PBEKeySpec(passphrase.toCharArray(), hex(salt), iterationCount, keySize);
            SecretKey key = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), "AES");
            return key;
        }
        catch (Exception e) {
           e.printStackTrace();
           return null;
        }
    }
    
    public static String random(int length) {
        byte[] salt = new byte[length];
        new SecureRandom().nextBytes(salt);
        return hex(salt);
    }
    
    public static String base64(byte[] bytes) {
        return DatatypeConverter.printBase64Binary(bytes);
    }
    
    public static byte[] base64(String str) {
        return DatatypeConverter.parseBase64Binary(str);
    }
    
    public static String hex(byte[] bytes) {
        return DatatypeConverter.printHexBinary(bytes);
    }
    
    public static byte[] hex(String str) {
        return DatatypeConverter.parseHexBinary(str);
    }
    
    private IllegalStateException fail(Exception e) {
        return new IllegalStateException(e);
    }
    
    public static void main(String[] args) {
       AesUtilHelper aesUtilHelper = new AesUtilHelper(128, 100);
       String pwd = aesUtilHelper.decrypt("00000000000000000000000000009876", "00000000000000000000000000004321", 
             "aesalgoisbestbes", "A4//CtwPO3WeAtvOmfDivw==");
       System.out.println(pwd);
   }
}
```

测试示例

```java
public void aes_test()throws UnsupportedEncodingException {
        String msg = "你好啊,啦啦啦啦";
        System.out.println(msg);
        String encrypt = AESUtil3.encrypt(msg);
        System.out.println(encrypt);
        String decrypt = AESUtil3.decrypt(encrypt);
        System.out.println(decrypt);
    }

//结果
//你好啊,啦啦啦啦
//A14DA66661D17A09385ED7337B6F6D3E7DDEFAFC1B761014FAEA8452D4BDBEBB
//你好啊,啦啦啦啦
```

##### 单向加密MD5

```java
public class MD5Util {
	String result = null;

	public static String textToMD5(String text) {
		String result = null;
		if (StringUtils.isBlank(text)) {
			return null;
		}
		try {
			// 首先进行实例化和初始化
			MessageDigest md = MessageDigest.getInstance("MD5");
			// 得到一个操作系统默认的字节编码格式的字节数组
			byte[] btInput = text.getBytes("UTF-8");
			// 对得到的字节数组进行处理
			md.update(btInput);
			// 进行哈希计算并返回结果
			byte[] btResult = md.digest();
			// 进行哈希计算后得到的数据的长度
			StringBuffer sb = new StringBuffer();
			for (byte b : btResult) {
				int bt = b & 0xff;
				if (bt < 16) {
					sb.append(0);
				}
				sb.append(Integer.toHexString(bt));
			}
			result = sb.toString();
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		return result;
	}
}
```

#### XSSFilter

```java
public class XSSFilter implements Filter {
   private static Map<String,String> xssMap = new LinkedHashMap<String,String>();
   @Override
   public void init(FilterConfig filterConfig) throws ServletException {
      xssMap.put("[s|S][c|C][r|R][i|C][p|P][t|T]", "");
      xssMap.put("[\\\"\\\'][\\s]*[j|J][a|A][v|V][a|A][s|S][c|C][r|R][i|I][p|P][t|T]:(.*)[\\\"\\\']", "\"\"");
      xssMap.put("[e|E][v|V][a|A][l|L]\\((.*)\\)", "");
      xssMap.put("<", "&lt;");
      xssMap.put(">", "&gt;");
      xssMap.put("\\(", "(");
      xssMap.put("\\)", ")");
      xssMap.put("'", "'");
      xssMap.put("\"", "“");

   }

   @Override
   public void doFilter(ServletRequest request, ServletResponse response,
         FilterChain chain) throws IOException, ServletException {
        HttpServletRequest httpReq = (HttpServletRequest)request;
        // 构造HttpRequestWrapper对象处理XSS
        HttpRequestWrapper httpReqWarp = new HttpRequestWrapper(httpReq,xssMap);
        chain.doFilter(httpReqWarp, response);
   }

   @Override
   public void destroy() {

   }

}
```



#### 防SQL注入

```java
public class SqlValidateUtil {

    private final static Logger log = Logger.getLogger(SqlValidateUtil.class);

    public static boolean sqlValidate(String str) {
        //包含sql注入返回true，不包含sql注入返回false
        str = str.toLowerCase();//统一转为小写
        String badStr = "'|and|exec|execute|insert|select|delete|update|count|drop|*|%|" +
                "char|declare|sitename|net user|xp_cmdshell|;| or |+|like'|create|drop|" +
                "table|from|grant|use|group_concat|column_name|" +
                "information_schema.columns|table_schema|union|where|order|by|*|" +
                "chr|mid|master|truncate|char|declare|;|--|,|like|//|/|%|#";//过滤掉的sql关键字，可以手动添加
        String[] badStrs = badStr.split("\\|");
        for (int i = 0; i < badStrs.length; i++) {
            if (str.indexOf(badStrs[i]) >= 0) {
                log.info("参数["+str+"]中包含注入sql:"+badStrs[i]);
                return true;
            }
        }
        return false;
    }
}
```

##### RSA公钥与私钥加密

```java
public class RsaUtil {
    private final String RSA_ALGORITHM = "RSA";
//    private final String RSA_ALGORITHM ="RSA/None/PKCS1Padding";
    private final String SIGNATURE_ALGORITHM = "MD5withRSA";
    private final String RSA_PUBLIC_KEY = "RSAPublicKey";
    private final String RSA_PRIVATE_KEY = "RSAPrivateKey";


    /**
     * 获取RSA算法私钥、公钥
     */
    public Map<String, Object> getKey() throws NoSuchAlgorithmException {
        Map<String, Object> keyMap = new HashMap<String, Object>(2);
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(RSA_ALGORITHM);
        keyPairGen.initialize(1024);//1024代表密钥二进制位数
        KeyPair keyPair = keyPairGen.generateKeyPair();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        keyMap.put(RSA_PUBLIC_KEY, publicKey);
        keyMap.put(RSA_PRIVATE_KEY, privateKey);
        return keyMap;
    }

    /**
     * 获取公钥
     */
    public String getPublicKey(Map<String, Object> map) {
        Key key = (Key) map.get(RSA_PUBLIC_KEY);
        return encodeBase64(key.getEncoded());
    }

    /**
     * 获取私钥
     */
    public String getPrivateKey(Map<String, Object> map) {
        Key key = (Key) map.get(RSA_PRIVATE_KEY);
        return encodeBase64(key.getEncoded());
    }

    /**
     * 使用私钥对数据进行加密
     */
    public byte[] encryptPrivateKey(byte[] binaryData, String privateKey) throws Exception {
        byte[] keyBytes = decodeBase64(privateKey);
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(RSA_ALGORITHM);
        Key priKey = keyFactory.generatePrivate(keySpec);
        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
        cipher.init(Cipher.ENCRYPT_MODE, priKey);
        return cipher.doFinal(binaryData);
    }

    /**
     * 使用公钥对数据进行加密
     */
    public byte[] encryptPublicKey(byte[] binaryData, String publicKey) throws Exception {
        byte[] keyBytes = decodeBase64(publicKey);
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(RSA_ALGORITHM);
        Key pubKey = keyFactory.generatePublic(keySpec);
        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
        cipher.init(Cipher.ENCRYPT_MODE, pubKey);
        return cipher.doFinal(binaryData);
    }

    /**
     * 使用私钥对数据进行解密
     */
    public byte[] decryptPrivateKey(byte[] binaryData, String privateKey) throws Exception {
        byte[] keyBytes = decodeBase64(privateKey);
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(RSA_ALGORITHM);
        Key priKey = keyFactory.generatePrivate(keySpec);
        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
        cipher.init(Cipher.DECRYPT_MODE, priKey);
        return cipher.doFinal(binaryData);
    }

    /**
     * 使用公钥对数据进行解密
     */
    public byte[] decryptPublicKey(byte[] binaryData, String publicKey) throws Exception {
        byte[] keyBytes = decodeBase64(publicKey);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(RSA_ALGORITHM);
        Key pubKey = keyFactory.generatePublic(x509KeySpec);
        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
        cipher.init(Cipher.DECRYPT_MODE, pubKey);
        return cipher.doFinal(binaryData);
    }
}
```

#### ZipUtils

//这里示例，注意两个文件夹不可以有依附关系

```java
//压缩
boolean b = ZipUtils.fileToZip("C:\\Users\\L\\Desktop\\zip_Test", "C:\\Users\\L\\Desktop\\zips", "压完了");
//解压        
String s = ZipUtils.unZip(new File("C:\\Users\\L\\Desktop\\zips\\压完了.zip"), "C:\\Users\\L\\Desktop\\zip_Test\\");
```

```java
public class ZipUtils {
    private final static Logger log = Logger.getLogger(ZipUtils.class);

    //不要问原理，不好意思，网上抄的
    public static boolean fileToZip(String sourceFilePath,String zipFilePath,String fileName){
        boolean flag = false;
        File sourceFile = new File(sourceFilePath);
        FileInputStream fis = null;
        BufferedInputStream bis = null;
        FileOutputStream fos = null;
        ZipOutputStream zos = null;

        if(!sourceFile.exists()){
            System.out.println("待压缩的文件目录："+sourceFilePath+"不存在.");
            sourceFile.mkdir(); // 新建目录
        }
        try {
            File zipFile = new File(zipFilePath + "/" + fileName +".zip");
            if(zipFile.exists()){
                System.out.println(zipFilePath + "目录下存在名字为:" + fileName +".zip" +"打包文件.");
            }else{
                File[] sourceFiles = sourceFile.listFiles();
                if(null == sourceFiles || sourceFiles.length<1){
                    System.out.println("待压缩的文件目录：" + sourceFilePath + "里面不存在文件，无需压缩.");
                }else{
                    fos = new FileOutputStream(zipFile);
                    zos = new ZipOutputStream(new BufferedOutputStream(fos));
                    byte[] bufs = new byte[1024*10];
                    for(int i=0;i<sourceFiles.length;i++){
                        //创建ZIP实体，并添加进压缩包
                        ZipEntry zipEntry = new ZipEntry(sourceFiles[i].getName());
                        zos.putNextEntry(zipEntry);
                        //读取待压缩的文件并写进压缩包里
                        fis = new FileInputStream(sourceFiles[i]);
                        bis = new BufferedInputStream(fis, 1024*10);
                        int read = 0;
                        while((read=bis.read(bufs, 0, 1024*10)) != -1){
                            zos.write(bufs,0,read);
                        }
                    }
                    flag = true;
                }
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        } catch (IOException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        } finally{
            //关闭流
            try {
                if(null != bis) bis.close();
                if(null != zos) zos.close();
            } catch (IOException e) {
                e.printStackTrace();
                throw new RuntimeException(e);
            }
        }
        return flag;
    }
    public static String unZip(File zipFile, String unzipFilePath) throws Exception {
        log.info("解压文件:" + zipFile + "到路径:" + unzipFilePath);
        String unzipPath = "";
        //判断文件是否存在
        if (!zipFile.exists() || zipFile.length() <= 0) {
            unzipPath = "false";
            return unzipPath;
        }
        if (zipFile.length() <= 0) {
            unzipPath = "false";
            return unzipPath;
        }
        //创建解压缩文件保存的路径
        File unzipFileDir = new File(unzipFilePath);
        //的判断文件夹是否存在如果存在则不创建 如果不存在 则创建
        if (!unzipFileDir.exists() || !unzipFileDir.isDirectory()) {
            //创建文件夹
            unzipFileDir.mkdirs();
        }
        //开始解压
        log.info("开始解压....");
        //创建解压对象
        ZipEntry zipEntry = null;
        //文件保存路径路径
        String entryFilePath = null;
        //文件夹路径
        String entryDirPath = null;
        //创建问价对象
        File entryFile = null;
        //创建文件夹对象
        File entryDir = null;
        int index = 0, count = 0, bufferSize = 1024;
        byte[] buffer = new byte[bufferSize];
        //创建输出字符流
        BufferedInputStream bufferedInputStream = null;
        //创建输入字符流
        BufferedOutputStream bufferedOutputStream = null;
        try {
            //创建压缩文件对象
            ZipFile zip = new ZipFile(zipFile);
            Enumeration<ZipEntry> entries = (Enumeration<ZipEntry>) zip.entries();
            //第一步循环创建文件夹 第二步创建文件 第三部写入文件
            while (entries.hasMoreElements()) {
                zipEntry = entries.nextElement();
                boolean isDir = zipEntry.isDirectory();
                //当前文件为文件夹
                if (isDir) {
                    String dir = zipEntry.getName();
                    entryFilePath = unzipFilePath + dir + "//";
                    //定义文件夹
                    entryDir = new File(entryFilePath);
                    //如果文件夹路径不存在，则创建文件夹
                    if (!entryDir.exists() || !entryDir.isDirectory()) {
                        entryDir.mkdirs();
                    }
                } else {
                    //当前是个文件
                    entryFilePath = unzipFilePath + zipEntry.getName();
                    File f = new File(entryFilePath);
                    if (index != -1) {
                        entryDirPath = f.getAbsolutePath().split(f.getName())[0];
                    } else {
                        entryDirPath = "";
                    }
                    log.info("entryDirPath:" + entryDirPath);
                    unzipPath = entryDirPath;
                    //定义文件夹
                    entryDir = new File(entryDirPath);
                    //如果文件夹路径不存在，则创建文件夹
                    if (!entryDir.exists() || !entryDir.isDirectory()) {
                        entryDir.mkdirs();
                    }
                    //创建解压文件
                    entryFile = new File(entryFilePath);
                    //写入文件
                    bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(entryFile));
                    //读取文件
                    bufferedInputStream = new BufferedInputStream(zip.getInputStream(zipEntry));
                    //文件写入
                    while ((count = bufferedInputStream.read(buffer, 0, bufferSize)) != -1) {
                        bufferedOutputStream.write(buffer, 0, count);
                    }
                    bufferedOutputStream.flush();
                    bufferedOutputStream.close();
                }
            }
            log.info("文件解压完毕...重新组装的路径是：" + unzipPath);
        } finally {
            try {
                if (null != bufferedInputStream) {
                    bufferedInputStream.close();
                }
                if (null != bufferedOutputStream) {
                    bufferedOutputStream.close();
                }
            } catch (Exception e2) {
            }
        }
        return unzipPath;
    }

}
```

#### (图像扭曲版)验证码工具类

```java
public class VerifyCodeServlet extends HttpServlet {

	public static final String VERIFY_CODES = "23456789ABCDEFGHJKLMNPQRSTUVWXYZ";
	private static Random random = new Random();

    //生成
	public static String generateVerifyCode(int verifySize, String sources) {
		if (sources == null || sources.length() == 0) {
			sources = VERIFY_CODES;
		}
		int codesLen = sources.length();
		Random rand = new Random(System.currentTimeMillis());
		StringBuilder verifyCode = new StringBuilder(verifySize);
		for (int i = 0; i < verifySize; i++) {
			verifyCode.append(sources.charAt(rand.nextInt(codesLen - 1)));
		}
		return verifyCode.toString();
	}

	public static void outputImage(int w, int h, OutputStream os, String code)
			throws IOException {
		int verifySize = code.length();
		BufferedImage image = new BufferedImage(w, h,
				BufferedImage.TYPE_INT_RGB);
		Random rand = new Random();
		Graphics2D g2 = image.createGraphics();
		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
		Color[] colors = new Color[5];
		Color[] colorSpaces = new Color[] { Color.WHITE, Color.CYAN,
				Color.GRAY, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
				Color.PINK, Color.YELLOW };
		float[] fractions = new float[colors.length];
		for (int i = 0; i < colors.length; i++) {
			colors[i] = colorSpaces[rand.nextInt(colorSpaces.length)];
			fractions[i] = rand.nextFloat();
		}
		Arrays.sort(fractions);

		g2.setColor(Color.GRAY);// 设置边框色
		g2.fillRect(0, 0, w, h);
        
		//设置背景颜色
		Color c = getRandColor(200, 250);
		g2.setColor(c);// 设置背景色
		g2.fillRect(0, 2, w, h - 4);
		//System.out.println("R:"+c.getRed() + " G:"+c.getGreen() + " B:"+c.getBlue());

		// 绘制干扰线
		Random random = new Random();
		g2.setColor(getRandColor(160, 200));// 设置线条的颜色
		for (int i = 0; i < 20; i++) {
			int x = random.nextInt(w - 1);
			int y = random.nextInt(h - 1);
			int xl = random.nextInt(6) + 1;
			int yl = random.nextInt(12) + 1;
			g2.drawLine(x, y, x + xl + 40, y + yl + 20);
		}

		// 添加噪点
/*		float yawpRate = 0.05f;// 噪声率
		int area = (int) (yawpRate * w * h);
		for (int i = 0; i < area; i++) {
			int x = random.nextInt(w);
			int y = random.nextInt(h);
			int rgb = getRandomIntColor();
			image.setRGB(x, y, rgb);
		}*/

		shear(g2, w, h, c);// 使图片扭曲
		
 		g2.setColor(getRandColor(100, 160));
		int fontSize = h - 4;
		Font font = new Font("Algerian", Font.ITALIC, fontSize);
		g2.setFont(font);
		char[] chars = code.toCharArray();
		for (int i = 0; i < verifySize; i++) {
			AffineTransform affine = new AffineTransform();
			affine.setToRotation(
					Math.PI / 4 * rand.nextDouble()
							* (rand.nextBoolean() ? 1 : -1), (w / verifySize)
							* i + fontSize / 2, h / 2);
			g2.setTransform(affine);
			g2.drawChars(chars, i, 1, ((w - 10) / verifySize) * i + 5, h / 2
					+ fontSize / 2 - 10);
		}

		g2.dispose();
		ImageIO.write(image, "jpg", os);
	}

	private static Color getRandColor(int fc, int bc) {
		if (fc > 255)
			fc = 255;
		if (bc > 255)
			bc = 255;
		int r = fc + random.nextInt(bc - fc);
		int g = fc + random.nextInt(bc - fc);
		int b = fc + random.nextInt(bc - fc);
		return new Color(r, g, b);
	}

	private static int getRandomIntColor() {
		int[] rgb = getRandomRgb();
		int color = 0;
		for (int c : rgb) {
			color = color << 8;
			color = color | c;
		}
		return color;
	}

	private static int[] getRandomRgb() {
		int[] rgb = new int[3];
		for (int i = 0; i < 3; i++) {
			rgb[i] = random.nextInt(255);
		}
		return rgb;
	}

	private static void shear(Graphics g, int w1, int h1, Color color) {
		shearX(g, w1, h1, color);
		shearY(g, w1, h1, color);
	}

	private static void shearX(Graphics g, int w1, int h1, Color color) {

		int period = random.nextInt(2);

		boolean borderGap = true;
		int frames = 1;
		int phase = random.nextInt(2);

		for (int i = 0; i < h1; i++) {
			double d = (double) (period >> 1)
					* Math.sin((double) i / (double) period
							+ (6.2831853071795862D * (double) phase)
							/ (double) frames);
			g.copyArea(0, i, w1, 1, (int) d, 0);
			if (borderGap) {
				g.setColor(color);
				g.drawLine((int) d, i, 0, i);
				g.drawLine((int) d + w1, i, w1, i);
			}
		}

	}

	private static void shearY(Graphics g, int w1, int h1, Color color) {

		int period = random.nextInt(30) + 10; // 50;

		boolean borderGap = true;
		int frames = 20;
		int phase = 7;
		for (int i = 0; i < w1; i++) {
			double d = (double) (period >> 1)
					* Math.sin((double) i / (double) period
							+ (6.2831853071795862D * (double) phase)
							/ (double) frames);
			g.copyArea(i, 0, 1, h1, 0, (int) d);
			if (borderGap) {
				g.setColor(color);
				g.drawLine(i, (int) d, i, 0);
				g.drawLine(i, (int) d + h1, i, h1);
			}

		}

	}

	@Override
	protected void service(HttpServletRequest request,
			HttpServletResponse response) throws ServletException, IOException {
		response.setHeader("Pragma", "No-cache");
		response.setHeader("Cache-Control", "no-cache");
		response.setDateHeader("Expires", 0);
		response.setContentType("image/jpeg");
		String verifyCode = generateVerifyCode(4, VERIFY_CODES);
		
		// 将验证码存入session
		HttpSession session = request.getSession(true);
		session.setAttribute("randCode", verifyCode.toLowerCase());
		System.out.println("randCode："+verifyCode);
		outputImage(YytxdConstants.VERIFY_WIDTH, YytxdConstants.VERIFY_HEIGTH, response.getOutputStream(), verifyCode);
	}
}
```

RedisUtil(简化redis的操作)

```java
public class RedisUtil {
    @Autowired
    private RedisTemplate redisTemplate11;

    //查询key是否存在
    public boolean hasKey(String key) {
        try {
            return redisTemplate11.hasKey(key);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    //删除缓存,入参可以多个
    @SuppressWarnings("unchecked")
    public void del(String... key) {
        if (key != null && key.length > 0) {
            if (key.length == 1) {
                redisTemplate11.delete(key[0]);
            } else {
                redisTemplate11.delete(CollectionUtils.arrayToList(key));
            }
        }
    }


    //普通缓存获取
    public Object get(String key) {
        return key == null ? null : redisTemplate11.opsForValue().get(key);
    }


    //=====================================================存===============================================

    //普通缓存放入
    public boolean set(String key, Object value) {
        try {
            redisTemplate11.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    //普通缓存放入，并设置失效时间
    public boolean set(String key, Object value, long time) {
        try {
            if (time > 0) {
                //这里设置一个缓存失效时间time（s）
                redisTemplate11.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            } else {
                set(key, value);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    public List<Object> getValueByKeys(List<String>keys){
        List<Object> list = redisTemplate11.executePipelined(new RedisCallback<Object>() {
            @Override
            public Object doInRedis(RedisConnection connection) {
                keys.forEach(key -> {
                    connection.get(redisTemplate11.getKeySerializer().serialize(key));
//                    connection.get(key.getBytes());
                });
                return null;
            }
        });
        return list;
    }

}
```

将sql获取的某列清单交给用户下载导出

```java
	/**
     * @Author: LGD
     * 获取发出的电话清单
     */
    @ResponseBody
    @RequestMapping(value = "/bma/getCampInfoToOutput", method = {RequestMethod.GET})
    public ResponseEntity<byte[]> getCampInfoToOutput(HttpServletRequest request) throws IOException {
        
        List<Map<String, Object>> phonemapList = jdbcTemplate.queryForList(sql,new Object[]{xx});
        ArrayList<String> phoneList = new ArrayList<>();
        for (Map m : phonemapList) {
            phoneList.add(String.valueOf((BigDecimal) m.get("PHONE_NUMBER")));
        }
        StringBuilder phoneTxt = new StringBuilder();
        for (String phone : phoneList) {
            phoneTxt.append(phone).append("\r\n");
        }
        File dir = new File(YytxdConstants.FILE_DIR);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        FileOutputStream fileOutputStream = new FileOutputStream(YytxdConstants.FILE_DIR + fileName);
        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream);
        outputStreamWriter.write(phoneTxt.toString());
        outputStreamWriter.close();
//        log.info(""+phoneList);
        HttpHeaders headers = new HttpHeaders();
        headers.setContentDispositionFormData("attachment", new String(( "xxx" + ".txt").getBytes("UTF-8"), "iso-8859-1"));
        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        return new ResponseEntity<byte[]>(
                FileUtils.readFileToByteArray(new File(YytxdConstants.FILE_DIR + fileName)),
                headers,
                HttpStatus.CREATED
        );
    }
```

#### EasyExcel相关使用

先导Maven

```xml
		<dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>easyexcel</artifactId>
            <version>3.1.1</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.83</version>
        </dependency>
```

创建监听器

```java
@Slf4j
public class DemoDataListener implements ReadListener<DemoData> {

    /**
     * 每隔5条存储数据库，实际使用中可以100条，然后清理list ，方便内存回收
     */
    private static final int BATCH_COUNT = 100;
    /**
     * 缓存的数据
     */
    private List<DemoData> cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);
    /**
     * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。
     */
    private DemoDAO demoDAO;

    public DemoDataListener() {
        // 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数
        demoDAO = new DemoDAO();
    }

    /**
     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来
     *
     * @param demoDAO
     */
    public DemoDataListener(DemoDAO demoDAO) {
        this.demoDAO = demoDAO;
    }

    /**
     * 这个每一条数据解析都会来调用
     *
     * @param data    one row value. Is is same as {@link AnalysisContext#readRowHolder()}
     * @param context
     */
    @Override
    public void invoke(DemoData data, AnalysisContext context) {
        log.info("解析到一条数据:{}" + JSON.toJSONString(data));
        cachedDataList.add(data);
        // 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM
        if (cachedDataList.size() >= BATCH_COUNT) {
            saveData();
            // 存储完成清理 list
            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);
        }
    }

    /**
     * 所有数据解析完成了 都会来调用
     *
     * @param context
     */
    @Override
    public void doAfterAllAnalysed(AnalysisContext context) {
        // 这里也要保存数据，确保最后遗留的数据也存储到数据库
        saveData();
        log.info("所有数据解析完成！");
    }

    /**
     * 加上存储数据库
     */
    private void saveData() {
        log.info("{}条数据，开始存储数据库！", cachedDataList.size());
        demoDAO.save(cachedDataList);
        log.info("存储数据库成功！");
    }
}
```

##### 读**excel**

//简单实用

```java
@Test
    void EasyExcelReadTest(){
        String fileName = "E:\\IDEA\\Springfamily\\springboot-tests\\springboot-test-01\\demoTest.xlsx";
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭
        EasyExcel.read(fileName, DemoData.class, new ReadListener<DemoData>() {
            /**
             * 单次缓存的数据量
             */
            public static final int BATCH_COUNT = 100;
            /**
             *临时存储
             */
            private List<DemoData> cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);

            @Override
            public void invoke(DemoData data, AnalysisContext context) {
                cachedDataList.add(data);
                if (cachedDataList.size() >= BATCH_COUNT) {
                    saveData();
                    // 存储完成清理 list
                    cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);
                }
            }

            //解析完后做什么
            @Override
            public void doAfterAllAnalysed(AnalysisContext context) {
                saveData();
            }

            /**
             * 加上存储数据库
             */
            private void saveData() {
                log.info(cachedDataList.size() + "条数据，开始存储数据库！");
                ArrayList<Object[]> objectList = new ArrayList<>();
                for (DemoData demoData : cachedDataList) {
                    Object[] objects = new Object[]{demoData.getString(),demoData.getDate(),demoData.getDoubleData()};
                    objectList.add(objects);
                }
                String isnertSql = "insert into excel_test(string,day,number) values(?,?,?)";
                int[] ints = jdbcTemplate.batchUpdate(isnertSql, objectList);
                int actualValue = ints.length;
                log.info("存储数据库成功！");
            }
        }).sheet().doRead();
    }
```

##### 写**Excel**

```java
@Test
    public void simpleWrite() {
        // 注意 simpleWrite在数据量不大的情况下可以使用（5000以内，具体也要看实际情况），数据量大参照 重复多次写入

        // 写法1 JDK8+
        // since: 3.0.0-beta1
        String fileName = "E:\\IDEA\\Easyweb-bokeShop\\demoTest.xlsx";
        // 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭
        // 如果这里想使用03 则 传入excelType参数即可
/*        EasyExcel.write(fileName, DemoData.class)
                .sheet("模板")
                .doWrite(() -> {
                    // 分页查询数据
                    return data();
                });*/

        // 写法2
        fileName = "E:\\IDEA\\Easyweb-bokeShop\\demoTest.xlsx";
        // 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭
        // 如果这里想使用03 则 传入excelType参数即可
        EasyExcel.write(fileName, DemoData.class).sheet("模板").doWrite(data());

/*        // 写法3
        fileName = TestFileUtil.getPath() + "simpleWrite" + System.currentTimeMillis() + ".xlsx";
        // 这里 需要指定写用哪个class去写
        try (ExcelWriter excelWriter = EasyExcel.write(fileName, DemoData.class).build()) {
            WriteSheet writeSheet = EasyExcel.writerSheet("模板").build();
            excelWriter.write(data(), writeSheet);
        }*/
    }
```

//所有方法

```java
	@Test
    public void simpleRead() {
        // 写法1：JDK8+ ,不用额外写一个DemoDataListener
        // since: 3.0.0-beta1
        String fileName = "E:\\IDEA\\Springfamily\\springboot-tests\\springboot-test-01\\demoTest.xlsx";
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭
        // 这里每次会读取100条数据 然后返回过来 直接调用使用数据就行
        EasyExcel.read(fileName, DemoData.class, new PageReadListener<DemoData>(dataList -> {
            for (DemoData demoData : dataList) {
                log.info("读取到一条数据" + JSON.toJSONString(demoData));
            }
        })).sheet().doRead();

        // 写法2：
        // 匿名内部类 不用额外写一个DemoDataListener
         fileName = "E:\\IDEA\\Springfamily\\springboot-tests\\springboot-test-01\\demoTest.xlsx";
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭
        EasyExcel.read(fileName, DemoData.class, new ReadListener<DemoData>() {
            /**
             * 单次缓存的数据量
             */
            public static final int BATCH_COUNT = 100;
            /**
             *临时存储
             */
            private List<DemoData> cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);

            @Override
            public void invoke(DemoData data, AnalysisContext context) {
                cachedDataList.add(data);
                if (cachedDataList.size() >= BATCH_COUNT) {
                    saveData();
                    // 存储完成清理 list
                    cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);
                }
            }

            //解析完后做什么
            @Override
            public void doAfterAllAnalysed(AnalysisContext context) {
                saveData();
            }

            /**
             * 加上存储数据库
             */
            private void saveData() {
                log.info("{}条数据，开始存储数据库！" + cachedDataList.size());
                log.info("存储数据库成功！");
            }
        }).sheet().doRead();

        // 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去
        // 写法3：
        fileName = "E:\\IDEA\\Springfamily\\springboot-tests\\springboot-test-01\\demoTest.xlsx";
        // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭
        EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).sheet().doRead();

        // 写法4
        fileName = "E:\\IDEA\\Springfamily\\springboot-tests\\springboot-test-01\\demoTest.xlsx";
        // 一个文件一个reader
        try (ExcelReader excelReader = EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).build()) {
            // 构建一个sheet 这里可以指定名字或者no
            ReadSheet readSheet = EasyExcel.readSheet(0).build();
            // 读取一个sheet
            excelReader.read(readSheet);
        }
    }
```



#### 使用unirest进行在java中调用接口

```xml
<dependency>
    <groupId>com.mashape.unirest</groupId>
    <artifactId>unirest-java</artifactId>
    <version>1.4.9</version>
</dependency>
```

传json返json如下

```java
org.json.JSONObject jsonObject = new org.json.JSONObject();
jsonObject.put("xx", "xxxx");
try {
    String respBody = Unirest.post(url)
            .header("Content-Type", "application/json")
            .body(jsonObject)
            .asString()
            .getBody();
    JSONObject jsonObject1 = JSONObject.fromObject(respBody);
}
```
